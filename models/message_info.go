package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MessageInfo message info
// swagger:model MessageInfo
type MessageInfo struct {

	// The list of message attachments
	Attachments []*MessageAttachmentInfo `json:"attachments"`

	// Message availability status. Message in 'Deleted' state is still preserved with all its attachments and can be restored. 'Purged' means that all attachments are already deleted and the message itself is about to be physically deleted shortly
	Availability string `json:"availability,omitempty"`

	// SMS and Pager only. Identifier of the conversation the message belongs to
	ConversationID int64 `json:"conversationId,omitempty"`

	// Message creation datetime in ISO 8601 format including timezone, for example 2016-03-10T18:07:52.534Z
	CreationTime strfmt.DateTime `json:"creationTime,omitempty"`

	// SMS only. Delivery error code returned by gateway
	DeliveryErrorCode string `json:"deliveryErrorCode,omitempty"`

	// Message direction. Note that for some message types not all directions are allowed. For example voicemail messages can be only inbound
	Direction string `json:"direction,omitempty"`

	// Fax only. Page count in fax message
	FaxPageCount int64 `json:"faxPageCount,omitempty"`

	// Fax only. Resolution of fax message. ('High' for black and white image scanned at 200 dpi, 'Low' for black and white image scanned at 100 dpi)
	FaxResolution string `json:"faxResolution,omitempty"`

	// Sender information
	From *MessageInfoCallerInfo `json:"from,omitempty"`

	// Internal identifier of a message
	ID string `json:"id,omitempty"`

	// The datetime when the message was modified on server in ISO 8601 format including timezone, for example 2016-03-10T18:07:52.534Z
	LastModifiedTime strfmt.DateTime `json:"lastModifiedTime,omitempty"`

	// Message status. Different message types may have different allowed status values.
	MessageStatus string `json:"messageStatus,omitempty"`

	// Pager only True if at least one of the message recipients is Department extension
	PgToDepartment bool `json:"pgToDepartment,omitempty"`

	// Message priority
	Priority string `json:"priority,omitempty"`

	// Message read status
	ReadStatus string `json:"readStatus,omitempty"`

	// SMS only. The datetime when outbound SMS was delivered to recipient's handset in ISO 8601 format including timezone, for example 2016-03-10T18:07:52.534Z. It is filled only if the carrier sends a delivery receipt to RingCentral
	SmsDeliveryTime strfmt.DateTime `json:"smsDeliveryTime,omitempty"`

	// SMS only. Number of attempts made to send an outbound SMS to the gateway (if gateway is temporary unavailable)
	SmsSendingAttemptsCount int64 `json:"smsSendingAttemptsCount,omitempty"`

	// Message subject. For SMS and Pager messages it replicates message text which is also returned as an attachment
	Subject string `json:"subject,omitempty"`

	// Recipient information
	To []*MessageInfoCallerInfo `json:"to"`

	// Message type
	Type string `json:"type,omitempty"`

	// Canonical URI of a message
	URI string `json:"uri,omitempty"`

	// Voicemail only. Status of voicemail to text transcription. If VoicemailToText feature is not activated for account, the 'NotAvailable' value is returned
	VMTranscriptionStatus string `json:"vmTranscriptionStatus,omitempty"`
}

// Validate validates this message info
func (m *MessageInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttachments(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateAvailability(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDirection(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFaxResolution(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFrom(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMessageStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePriority(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateReadStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVMTranscriptionStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MessageInfo) validateAttachments(formats strfmt.Registry) error {

	if swag.IsZero(m.Attachments) { // not required
		return nil
	}

	for i := 0; i < len(m.Attachments); i++ {

		if swag.IsZero(m.Attachments[i]) { // not required
			continue
		}

		if m.Attachments[i] != nil {

			if err := m.Attachments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attachments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var messageInfoTypeAvailabilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Alive","Deleted","Purged"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageInfoTypeAvailabilityPropEnum = append(messageInfoTypeAvailabilityPropEnum, v)
	}
}

const (
	// MessageInfoAvailabilityAlive captures enum value "Alive"
	MessageInfoAvailabilityAlive string = "Alive"
	// MessageInfoAvailabilityDeleted captures enum value "Deleted"
	MessageInfoAvailabilityDeleted string = "Deleted"
	// MessageInfoAvailabilityPurged captures enum value "Purged"
	MessageInfoAvailabilityPurged string = "Purged"
)

// prop value enum
func (m *MessageInfo) validateAvailabilityEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageInfoTypeAvailabilityPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MessageInfo) validateAvailability(formats strfmt.Registry) error {

	if swag.IsZero(m.Availability) { // not required
		return nil
	}

	// value enum
	if err := m.validateAvailabilityEnum("availability", "body", m.Availability); err != nil {
		return err
	}

	return nil
}

var messageInfoTypeDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Inbound","Outbound"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageInfoTypeDirectionPropEnum = append(messageInfoTypeDirectionPropEnum, v)
	}
}

const (
	// MessageInfoDirectionInbound captures enum value "Inbound"
	MessageInfoDirectionInbound string = "Inbound"
	// MessageInfoDirectionOutbound captures enum value "Outbound"
	MessageInfoDirectionOutbound string = "Outbound"
)

// prop value enum
func (m *MessageInfo) validateDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageInfoTypeDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MessageInfo) validateDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.Direction) { // not required
		return nil
	}

	// value enum
	if err := m.validateDirectionEnum("direction", "body", m.Direction); err != nil {
		return err
	}

	return nil
}

var messageInfoTypeFaxResolutionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["High","Low"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageInfoTypeFaxResolutionPropEnum = append(messageInfoTypeFaxResolutionPropEnum, v)
	}
}

const (
	// MessageInfoFaxResolutionHigh captures enum value "High"
	MessageInfoFaxResolutionHigh string = "High"
	// MessageInfoFaxResolutionLow captures enum value "Low"
	MessageInfoFaxResolutionLow string = "Low"
)

// prop value enum
func (m *MessageInfo) validateFaxResolutionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageInfoTypeFaxResolutionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MessageInfo) validateFaxResolution(formats strfmt.Registry) error {

	if swag.IsZero(m.FaxResolution) { // not required
		return nil
	}

	// value enum
	if err := m.validateFaxResolutionEnum("faxResolution", "body", m.FaxResolution); err != nil {
		return err
	}

	return nil
}

func (m *MessageInfo) validateFrom(formats strfmt.Registry) error {

	if swag.IsZero(m.From) { // not required
		return nil
	}

	if m.From != nil {

		if err := m.From.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("from")
			}
			return err
		}
	}

	return nil
}

var messageInfoTypeMessageStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Queued","Sent","Delivered","DeliveryFailed","SendingFailed","Received"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageInfoTypeMessageStatusPropEnum = append(messageInfoTypeMessageStatusPropEnum, v)
	}
}

const (
	// MessageInfoMessageStatusQueued captures enum value "Queued"
	MessageInfoMessageStatusQueued string = "Queued"
	// MessageInfoMessageStatusSent captures enum value "Sent"
	MessageInfoMessageStatusSent string = "Sent"
	// MessageInfoMessageStatusDelivered captures enum value "Delivered"
	MessageInfoMessageStatusDelivered string = "Delivered"
	// MessageInfoMessageStatusDeliveryFailed captures enum value "DeliveryFailed"
	MessageInfoMessageStatusDeliveryFailed string = "DeliveryFailed"
	// MessageInfoMessageStatusSendingFailed captures enum value "SendingFailed"
	MessageInfoMessageStatusSendingFailed string = "SendingFailed"
	// MessageInfoMessageStatusReceived captures enum value "Received"
	MessageInfoMessageStatusReceived string = "Received"
)

// prop value enum
func (m *MessageInfo) validateMessageStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageInfoTypeMessageStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MessageInfo) validateMessageStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.MessageStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateMessageStatusEnum("messageStatus", "body", m.MessageStatus); err != nil {
		return err
	}

	return nil
}

var messageInfoTypePriorityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Normal","High"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageInfoTypePriorityPropEnum = append(messageInfoTypePriorityPropEnum, v)
	}
}

const (
	// MessageInfoPriorityNormal captures enum value "Normal"
	MessageInfoPriorityNormal string = "Normal"
	// MessageInfoPriorityHigh captures enum value "High"
	MessageInfoPriorityHigh string = "High"
)

// prop value enum
func (m *MessageInfo) validatePriorityEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageInfoTypePriorityPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MessageInfo) validatePriority(formats strfmt.Registry) error {

	if swag.IsZero(m.Priority) { // not required
		return nil
	}

	// value enum
	if err := m.validatePriorityEnum("priority", "body", m.Priority); err != nil {
		return err
	}

	return nil
}

var messageInfoTypeReadStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Read","Unread"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageInfoTypeReadStatusPropEnum = append(messageInfoTypeReadStatusPropEnum, v)
	}
}

const (
	// MessageInfoReadStatusRead captures enum value "Read"
	MessageInfoReadStatusRead string = "Read"
	// MessageInfoReadStatusUnread captures enum value "Unread"
	MessageInfoReadStatusUnread string = "Unread"
)

// prop value enum
func (m *MessageInfo) validateReadStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageInfoTypeReadStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MessageInfo) validateReadStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.ReadStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateReadStatusEnum("readStatus", "body", m.ReadStatus); err != nil {
		return err
	}

	return nil
}

func (m *MessageInfo) validateTo(formats strfmt.Registry) error {

	if swag.IsZero(m.To) { // not required
		return nil
	}

	for i := 0; i < len(m.To); i++ {

		if swag.IsZero(m.To[i]) { // not required
			continue
		}

		if m.To[i] != nil {

			if err := m.To[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("to" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var messageInfoTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Fax","SMS","VoiceMail","Pager","Text"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageInfoTypeTypePropEnum = append(messageInfoTypeTypePropEnum, v)
	}
}

const (
	// MessageInfoTypeFax captures enum value "Fax"
	MessageInfoTypeFax string = "Fax"
	// MessageInfoTypeSMS captures enum value "SMS"
	MessageInfoTypeSMS string = "SMS"
	// MessageInfoTypeVoiceMail captures enum value "VoiceMail"
	MessageInfoTypeVoiceMail string = "VoiceMail"
	// MessageInfoTypePager captures enum value "Pager"
	MessageInfoTypePager string = "Pager"
	// MessageInfoTypeText captures enum value "Text"
	MessageInfoTypeText string = "Text"
)

// prop value enum
func (m *MessageInfo) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageInfoTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MessageInfo) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

var messageInfoTypeVMTranscriptionStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NotAvailable","InProgress","TimedOut","Completed","CompletedPartially","Failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageInfoTypeVMTranscriptionStatusPropEnum = append(messageInfoTypeVMTranscriptionStatusPropEnum, v)
	}
}

const (
	// MessageInfoVMTranscriptionStatusNotAvailable captures enum value "NotAvailable"
	MessageInfoVMTranscriptionStatusNotAvailable string = "NotAvailable"
	// MessageInfoVMTranscriptionStatusInProgress captures enum value "InProgress"
	MessageInfoVMTranscriptionStatusInProgress string = "InProgress"
	// MessageInfoVMTranscriptionStatusTimedOut captures enum value "TimedOut"
	MessageInfoVMTranscriptionStatusTimedOut string = "TimedOut"
	// MessageInfoVMTranscriptionStatusCompleted captures enum value "Completed"
	MessageInfoVMTranscriptionStatusCompleted string = "Completed"
	// MessageInfoVMTranscriptionStatusCompletedPartially captures enum value "CompletedPartially"
	MessageInfoVMTranscriptionStatusCompletedPartially string = "CompletedPartially"
	// MessageInfoVMTranscriptionStatusFailed captures enum value "Failed"
	MessageInfoVMTranscriptionStatusFailed string = "Failed"
)

// prop value enum
func (m *MessageInfo) validateVMTranscriptionStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageInfoTypeVMTranscriptionStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *MessageInfo) validateVMTranscriptionStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.VMTranscriptionStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateVMTranscriptionStatusEnum("vmTranscriptionStatus", "body", m.VMTranscriptionStatus); err != nil {
		return err
	}

	return nil
}
